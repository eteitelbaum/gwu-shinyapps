{
  "hash": "13feb7fea1724e660ad613602a245a18",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Module 2.3\"\nsubtitle: \"Line Chart App Server\"\nformat: \n  html:\n    code-link: true\nhighlight-style: atom-one\nexecute:\n  echo: true\n  message: false\n  warning: false\n---\n\n\n::: {.callout-tip}\n## Prework\n\n- Read *Mastering Shiny*, [Chapter 3](https://mastering-shiny.org/basic-reactivity.html), section 3.4\n:::\n\n{{< video https://youtu.be/UHYpaEVjwRE title = 'FRED App Server'>}}\n\n## The Server Function\n\nFor our server function, we are going to define two separate `reactive()` functions. This is how we are going to dynamically update the plot based on two different user inputs. First, we will define an input for the indicator where `input$indicator` takes the user input from the dropdown menu to perform a fresh API call whenever the selected indicator changes. Then, we take that input and filter it based on the input from the slider, e.g. `input$range`. Then we render the plot based on these updated data. \nNotice that whenever we want to use the stored data from the reactive calls we need to add parentheses after the objects, e.g. `fred_indicator()` in the second reactive function or `fred_data()` in the `ggplot` call. This is to ensure that the reactive expression is evaluated and its current value is used as the input data for the plot. \n\nFinally, we are going to use the `add_rec_shade()` helper function to add the recession shading to the chart. We again use the inputs from the two reactive functions to define the start date and end date of the shading as well as the y-min and y-max values of the shaded rectangles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output) {\n  \n    # Download data from FRED with reactive function. \n    # Only updates when user selects new indicator\n    fred_indicator <- reactive({\n      fredr(series_id = input$indicator,\n        observation_start = start_date,\n        observation_end = end_date)\n    })\n  \n    # Filter data according to chosen years \n    # Only updates when user selects new data range\n    fred_data <- reactive({\n      fred_indicator() |>\n      filter(between(date, input$range[1],input$range[2])) \n   })\n\n    # Render line chart\n    output$lineChart <- renderPlot({\n      \n      # Build plot with ggplot2\n      ggplot(fred_data(), aes(x = date, y = value)) + \n        geom_line(color = \"navyblue\") +\n        labs(\n          x = \"\", \n          y =  names(vars[which(vars == input$indicator)])\n        ) +\n        theme_minimal() +\n        # add recession shading\n        add_rec_shade(st_date = input$range[1], \n                      ed_date = input$range[2], \n                      shade_color = \"darkgrey\",\n                      y_min = min(fred_data()$value),\n                      y_max = max(fred_data()$value))\n    })\n}\n```\n:::\n\n\n## Call to Shiny app\n\nOnce we have our UI and server functions defined we are ready to go. But don't forget to include the call to the Shiny app or the app won't run! Once this is in place, you can click \"Run App\" in the RStudio IDE to view the app locally. Optionally, right now, you can try setting up an account on [shinyapps.io](https://www.shinyapps.io/) and try publishing your app on their server. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# See above for the definitions of ui and server\nui <- ...\n\nserver <- ...\n\n# Run the application \nshinyApp(ui = ui, server = server)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}