{
  "hash": "e338966dbd9c35d666e00e9d28d0a3db",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"WebApps 6502\"\nsubtitle: \"Session 2.1--Observers and Reactives\"\nfooter: \"[WebApps Website](https://rshiny-is.cool)\"\nlogo: images/webapps-logo.png\nformat:\n  revealjs:\n    theme: [simple, custom.scss]\n    transition: fade\n    slide-number: true\n    chalkboard: true\nexecute:\n  echo: true\n  eval: false\n  freeze: auto\n---\n\n\n# Observers\n\n## Observers\n\nSo far, we used `render*` functions to produce our output. All of the action with those functions happens inside of the app.\n\n<br>\n\nBut sometimes, we want to reach **outside the app**: call an API, send data to a database, send debugging messages. We want to call a function for its \"side-effects.\"\n\n<br>\n\nWe need **observers** for that!\n\n## Observers\n\nObservers are functions that run when their dependencies change, just like outputs.\n\n<br>\n\nBut unlike output rendering functions that directly update the UI, observers handle tasks that can affect the application state or perform other \"side effects.\"\n\n## Types of Observers\n\n- **`observe({})`**: Automatically re-executes when any of its reactive dependencies change.\n- **`observeEvent(event, { })`**: Executes in response to a specific event, offering more control over reactivity and allowing you to ignore changes in other inputs.\n\n## What Are Side Effects?\n\nIn the context of Shiny, a side effect refers to any action performed by an observer that affects the state of the application or external systems but does not directly result in UI output. These include:\n\n- Modifying application state\n- Interacting with databases\n- Sending data to external APIs\n- Writing to or reading from files\n\n## Example: Printing to Console\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"19-21\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  numericInput(inputId = \"number\", \n               label = \"Enter a number\", \n               value = 0),\n               \n  actionButton(inputId = \"button\", \n               label = \"Click me\"),\n               \n  textOutput(outputId = \"text\")\n)\n\nserver <- function(input, output, session) {\n  output$text <- renderText({\n    input$number^2\n  }) |> bindEvent(input$button)\n  \n  observe({\n    print(input$number^2)\n  })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n## Example: Printing to Console\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"21\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  numericInput(inputId = \"number\", \n               label = \"Enter a number\", \n               value = 0),\n               \n  actionButton(inputId = \"button\", \n               label = \"Click me\"),\n               \n  textOutput(outputId = \"text\")\n)\n\nserver <- function(input, output, session) {\n  output$text <- renderText({\n    input$number^2\n  }) |> bindEvent(input$button)\n  \n  observe({\n    print(input$number^2)\n  }) |> bindEvent(input$button)\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n## Example: Resetting Values\n\n[Democracy Around the World!](https://emmanuelteitelbaum.shinyapps.io/vdem-dashboard) App.\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  # Observe changes to region selection\n  observeEvent(input$regions, {\n    if (input$regions == \"Global\") {\n      # Reset the selected country and display global trend when \"Global\" is chosen\n      selected_country(NULL)\n    } else {\n      # Reset the selected country when any specific region is chosen\n      selected_country(NULL)\n    }\n  })\n```\n:::\n\n\n# Reactives\n\n## What Reactives Do\n\n**Reactives** are functions that **return a value**. You can assign them to an object and you can refer to reactives elsewhere in your app. \n\n<br>\n\nYou can see them as backpacks ðŸŽ’ that carry values and expressions around that you can open whenever you want.\n\n## Types of Reactive Functions\n\nWhen you go hiking, you pick a backpack that fits your needs. There are **different types** of backpacks that are fit **to carry different things**.\n\n<br>\n\nThat's similar with a reactive. They carry different things:\n\n- **reactive()**: takes an expression\n- **reactiveVal()**: takes a single value\n- **reactiveValues()**: takes a list of values\n\n# The `reactive()` Function\n\n## The `reactive()` Function\n\nYou can see `reactive()` as a very fancy full-size backpack ðŸŽ’ðŸŒŸ. \n\n<br>\n\nIt can take multiple inputs, manipulate them and return something simple (a value) or complex (a plot, a table). It can even take other reactives (other backpacks) as input!\n\n## `reactive()` Example\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"15-17,20,24\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  numericInput(inputId = \"number\", \n               label = \"Enter a number\", \n               value = 0),\n               \n  actionButton(inputId = \"button\", \n               label = \"Click me\"),\n               \n  textOutput(outputId = \"text\")\n)\n\nserver <- function(input, output, session) {\n  number_squared <- reactive({\n    input$number^2\n  }) |> bindEvent(input$button)\n  \n  output$text <- renderText({\n    number_squared()\n  })\n  \n  observe({\n    print(number_squared())\n  })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n## Laziness\n\nThis fancy backpack is only opened when you ask for it. It is therefore **lazy**.\n\n<br>\n\nMore technical: when the dependencies of a reactive change, it doesn't re-execute right away but rather waits until it gets called by something else.\n\n\n## Reactive Values\n\n If `reactive()` is a fancy backpack, **reactive values** are simpler backpacks. They carry one or more value(s) that you can unpack, but also update.\n\n<br>\n\nYou make a reactive single value with `reactiveVal()` and you can update it by calling it with a new value.\n\n<br>\n\nYou can make multiple reactive values with `reactiveValues()` and you can update them by assigning a new value to them.\n\n## `reactiveVal()` Example\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"15,17-19,22,26\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  numericInput(inputId = \"number\", \n               label = \"Enter a number\", \n               value = 0),\n               \n  actionButton(inputId = \"button\", \n               label = \"Click me\"),\n               \n  textOutput(outputId = \"text\")\n)\n\nserver <- function(input, output, session) {\n  number_squared <- reactiveVal(0)\n  \n  observe({\n    number_squared(input$number^2)\n  }) |> bindEvent(input$button)\n  \n  output$text <- renderText({\n    number_squared()\n  })\n  \n  observe({\n    print(number_squared())\n  })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n## `reactiveValues()` Example\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"15,17-19,22,26\"}\nlibrary(shiny)\n\nui <- fluidPage(\n  numericInput(inputId = \"number\", \n               label = \"Enter a number\", \n               value = 0),\n               \n  actionButton(inputId = \"button\", \n               label = \"Click me\"),\n               \n  textOutput(outputId = \"text\")\n)\n\nserver <- function(input, output, session) {\n  r <- reactiveValues(number_squared = 0) \n  \n  observe({\n    r$number_squared <- input$number^2\n  }) |> bindEvent(input$button)\n  \n  output$text <- renderText({\n    r$number_squared\n  })\n  \n  observe({\n    print(r$number_squared)\n  })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n## Reactive Values\n\nYou can see `reactiveValues()` as some kind of reactive mini-database. You can use it to store multiple values, retrieve them in different places, and update them. \n\n<br>\n\nAnd since it's reactive, you can use it to **trigger other parts of your app** when one of its values changes.\n\n# Line Chart App\n\n## Example from this Week {.center}\n\n<iframe src=\"https://emmanuelteitelbaum.shinyapps.io/fred_app/\" width=\"780\" height=\"500\" data-external=\"1\"></iframe>\n\n## Server with `reactive()` Functions\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    # Download data from FRED with reactive function. \n    # Only updates when user selects new indicator\n    fred_indicator <- reactive({\n      fredr(series_id = input$indicator,\n        observation_start = start_date,\n        observation_end = end_date)\n    })\n  \n    # Filter data according to chosen years \n    # Only updates when user selects new data range\n    fred_data <- reactive({\n      fred_indicator() |>\n      filter(between(date, input$range[1],input$range[2])) \n   })\n```\n:::\n\n\n## Key Concepts {.smaller}\n\n- **Focused Reactivity**: \n  - Each `reactive()` function isolates updates to specific user inputs.\n  - This avoids redundant processing and enhances app performance.\n  \n- **Chained Dependencies**:\n  - `reactive()` functions can depend on each other.\n  - Changes in one reactive output can trigger updates in another, maintaining efficient data flow.\n\n- **Selective Execution**:\n  - Reduces the computational workload by recalculating only necessary parts of the data pipeline.\n  - Reactivity is triggered only in response to relevant user interactions.\n\n## UI Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- fluidPage(\n\n    # Application title\n    titlePanel(\"FRED Data App\"),\n    \n    fluidRow(\n      \n      # 12 columns on one row: this panel will take 1/3 of it\n      column(4, wellPanel(\n        selectInput(\"indicator\", \"Indicator:\", vars)\n        ),\n      helpText(\"Select an indicator, choose a date range and view the trend. \n               The grey bars represent economic recessions. \n               The data for this app comes from the St. Louis Fed's \n               FRED database. The consumer confidence, business confidence and \n               lead composite indicators are OECD data downloaded through FRED.\")\n      ), \n      \n      # Remaining 2/3 occupied by plot\n      column(8,\n        plotOutput(\"lineChart\"),     \n        sliderInput(\n          \"range\",\n          \"\",\n          min = start_date,\n          max = end_date, \n          value = c(start_date, end_date), \n          width = \"100%\"\n        )\n      )\n    )\n)\n```\n:::\n\n\n## Setup (Global) Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(shiny)\nlibrary(fredr)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n# Set Fred API key \nfredr_set_key(\"YOUR FRED API KEY\") \n\n# Assign FRED series to objects\ncci <- \"CSCICP03USM665S\" # consumer confidence\nbci <- \"BSCICP03USM665S\" # business confidence\ncli <- \"USALOLITONOSTSAM\" # composite lead indicator\nunemp_rate <- \"UNRATE\" # unemployment rate\ngrowth <- \"A191RL1Q225SBEA\" # growth rate\n\n# set start and end date\nstart_date <- as.Date(\"1970-01-01\")\nend_date <- as.Date(Sys.Date())\n\n# Create list of named values for the input selection\nvars <- c(\"Consumer Confidence\" = cci, \n          \"Business Confidence\" = bci, \n          \"Composite Indicator\" = cli, \n          \"Unemployment Rate\" = unemp_rate,\n          \"Growth Rate\" = growth)\n\n# Load helper script\nsource(\"helper.R\") # scroll down, code pasted below\n```\n:::\n\n\n\n## Your Turn! {.smaller}\n\n<br>\n\n- Do the prework, getting set up with `fredr` and other relevant packages\n- Create a NEW project folder\n- Save your helper script in a subfolder\n- Start on your app.R file\n- Extend the app by incorporating new indicators\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"countdown\" id=\"timer1\" data-update-every=\"1\" tabindex=\"0\" style=\"right:10%;bottom:10%;\">\n<div class=\"countdown-controls\"><button class=\"countdown-bump-down\">&minus;</button><button class=\"countdown-bump-up\">&plus;</button></div>\n<code class=\"countdown-time\"><span class=\"countdown-digits minutes\">10</span><span class=\"countdown-digits colon\">:</span><span class=\"countdown-digits seconds\">00</span></code>\n</div>\n```\n\n:::\n:::\n\n\n## Challenge 1--Observers {.smaller}\n\n- **Notification Management**:\n  - Implement `observeEvent()` using `showNotification()` to show notifications when indicators are selected.\n- **Action Logging**:\n  - Log changes to the indicator or date range to the R console with timestamps.\n- **Dynamic UI Updates**:\n  - Use `observe()` to adjust the UI elements dynamically based on the indicator selected.\n\n\n## Challenge 2--Reactives {.smaller}\n\n- Implement a counter using `reactiveValues()` that increments each time the indicator input changes.\n  - Display the counter value in the UI using `textOutput()`.\n  - Use `observeEvent()` to increment the counter reactively.\n- Create UI controls for selecting plot line type and color.\n  - Use `reactiveValues()` to store the current plot style settings.\n  - Update the plot rendering logic to use these settings dynamically.\n- Update our app to include vertical lines on the plot that show \"black swan\" events\n  - Use check boxes to allow users to select which events to display\n  - Use `reactiveValues()` to store the selected events, then plot\n  \n## Acknowledgements\n\n- Parts of this presentation were adapted from Veerle van Leemput's [Shiny 101: The Modular App Blueprint](https://github.com/hypebright/shinyconf2024-shiny101)\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/countdown-0.4.0/countdown.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/countdown-0.4.0/countdown.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}